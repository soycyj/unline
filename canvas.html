<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Unline Canvas</title>
  <style>
    :root{
      --bg:#0b0d10;
      --panel:rgba(20,24,33,0.92);
      --line:rgba(39,48,68,0.9);
      --text:#e8eef9;
      --muted:#a9b4c7;
      --btn:#1f6feb;
      --btn2:#2b3242;
      --danger:#ef4444;
      --ok:#22c55e;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      background:var(--bg);
      color:var(--text);
      font-family:system-ui,-apple-system,Segoe UI,Roboto;
      display:flex;
      flex-direction:column;
      height:100%;
    }
    .topbar{
      display:flex;
      gap:10px;
      align-items:center;
      justify-content:space-between;
      padding:10px 12px;
      border-bottom:1px solid var(--line);
      background:rgba(10,12,16,0.6);
      backdrop-filter: blur(6px);
    }
    .left, .right{
      display:flex;
      gap:10px;
      align-items:center;
      flex-wrap:wrap;
    }
    .pill{
      padding:6px 10px;
      border-radius:999px;
      border:1px solid var(--line);
      background:rgba(20,24,33,0.6);
      font-size:12px;
      color:var(--muted);
    }
    .pill strong{color:var(--text);font-weight:800}
    .status{
      padding:6px 10px;
      border-radius:999px;
      border:1px solid var(--line);
      font-size:12px;
      font-weight:900;
      letter-spacing:0.2px;
    }
    .online{color:#052e12;background:rgba(34,197,94,0.18);border-color:rgba(34,197,94,0.4)}
    .offline{color:#450a0a;background:rgba(239,68,68,0.16);border-color:rgba(239,68,68,0.35)}
    button{
      padding:9px 12px;
      border:1px solid var(--line);
      border-radius:12px;
      cursor:pointer;
      color:var(--text);
      background:var(--btn2);
      font-weight:800;
      font-size:13px;
    }
    button.primary{background:var(--btn);border-color:rgba(31,111,235,0.7)}
    button.danger{background:rgba(239,68,68,0.12);border-color:rgba(239,68,68,0.35);color:#fecaca}
    button.ghost{background:transparent}
    button.active{background:rgba(31,111,235,0.18);border-color:rgba(31,111,235,0.5)}
    button:disabled{opacity:0.55;cursor:not-allowed}
    input{
      padding:9px 12px;
      border-radius:12px;
      border:1px solid var(--line);
      background:rgba(10,12,16,0.55);
      color:var(--text);
      font-weight:800;
      font-size:13px;
      outline:none;
      width:160px;
    }
    select{
      padding:9px 12px;
      border-radius:12px;
      border:1px solid var(--line);
      background:rgba(10,12,16,0.55);
      color:var(--text);
      font-weight:800;
      font-size:13px;
      outline:none;
    }
    .wrap{
      display:grid;
      grid-template-columns:260px 1fr 320px;
      gap:12px;
      padding:12px;
      height:calc(100% - 56px);
    }
    .stage{
      background:var(--panel);
      border:1px solid var(--line);
      border-radius:16px;
      overflow:hidden;
      position:relative;
    }
    canvas{
      width:100%;
      height:100%;
      display:block;
      touch-action:none;
      background:rgba(10,12,16,0.55);
    }
    .col{display:flex;flex-direction:column;gap:12px}
    .card{
      background:var(--panel);
      border:1px solid var(--line);
      border-radius:16px;
      padding:12px;
    }
    .card h3{
      margin:0 0 10px;
      font-size:13px;
      color:var(--muted);
      font-weight:900;
      letter-spacing:0.3px;
      text-transform:uppercase;
    }
    .row{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
    .small{font-size:12px;color:var(--muted);line-height:1.55;margin:8px 0 0}
    .swatches{display:flex;gap:8px;flex-wrap:wrap}
    .swatch{
      width:24px;height:24px;border-radius:8px;
      border:1px solid var(--line);
      cursor:pointer;
      outline:none;
    }
    .swatch.active{
      border-color:rgba(232,238,249,0.95);
      box-shadow:0 0 0 2px rgba(232,238,249,0.25) inset;
    }
    .banner{
      margin-top:10px;
      padding:10px 12px;
      border-radius:14px;
      border:1px solid rgba(245,158,11,0.35);
      background:rgba(245,158,11,0.10);
      color:#fde68a;
      font-size:12px;
      line-height:1.55;
      display:none;
    }
    @media (max-width:1060px){
      .wrap{grid-template-columns:1fr}
      input{width:140px}
    }
  </style>
</head>
<body>
  <div class="topbar">
    <div class="left">
      <div id="connStatus" class="status offline">Offline</div>
      <div class="pill">Room <strong id="roomTxt"></strong></div>
      <div class="pill">Role <strong id="roleTxt">Unknown</strong></div>
      <div class="pill">Visitors <strong id="visitorsTxt">0</strong></div>
      <div class="pill">Label <strong id="labelTxt">None</strong></div>
    </div>
    <div class="right">
      <input id="roomInput" placeholder="Room code" />
      <button id="goRoomBtn">Go</button>
      <button id="clearBtn" class="danger">Clear</button>
      <button id="backBtn" class="ghost">Back</button>
      <button id="endSessionBtn" class="danger" style="display:none">End session</button>
    </div>
  </div>

  <div class="wrap">
    <div class="col">
      <div class="card">
        <h3>Tools</h3>
        <div class="row">
          <button id="toolPen" class="active">Pen</button>
          <button id="toolEraser">Eraser</button>
        </div>

        <div class="row" style="margin-top:10px">
          <div class="swatches" id="swatches"></div>
        </div>

        <div class="row" style="margin-top:10px">
          <div class="small">Size</div>
          <select id="sizeSel">
            <option value="2">2</option>
            <option value="3" selected>3</option>
            <option value="5">5</option>
            <option value="8">8</option>
            <option value="12">12</option>
          </select>
        </div>

        <div class="banner" id="viewerBanner">
          Viewer 모드입니다. 현재 room에서 그리기와 음성은 참가자만 가능합니다.
          참가자 링크로 다시 입장하면 바로 사용 가능합니다.
        </div>

        <p class="small" id="toolInfo"></p>
      </div>
    </div>

    <div class="stage">
      <canvas id="board"></canvas>
    </div>

    <div class="col">
      <div class="card">
        <h3>Voice</h3>
        <div class="row">
          <button class="primary" id="startVoiceBtn">Start voice</button>
          <button class="danger" id="stopVoiceBtn" disabled>Stop</button>
        </div>
        <p class="small" id="voiceState">Idle</p>
        <audio id="remoteAudio" autoplay playsinline></audio>
        <p class="small" id="voiceHint"></p>
      </div>
    </div>
  </div>

  <script>
    const $ = (id) => document.getElementById(id);

    function setConn(online){
      const el = $("connStatus");
      if(online){
        el.textContent = "Online";
        el.classList.remove("offline");
        el.classList.add("online");
      }else{
        el.textContent = "Offline";
        el.classList.remove("online");
        el.classList.add("offline");
      }
    }

    function genClientId(){
      return "c" + Math.random().toString(16).slice(2,10);
    }

    const qs = new URLSearchParams(location.search);
    let room = (qs.get("room") || "").trim();
    if(!room) room = "TEST";

    const label = (qs.get("label") || "").trim();
    $("labelTxt").textContent = label || "None";

    const userProvidedClientId = !!(qs.get("clientId") || "").trim();

    let clientId = (qs.get("clientId") || "").trim();
    if(!clientId){
      const key = `unline_auto_clientId_${room}`;
      clientId = localStorage.getItem(key) || genClientId();
      localStorage.setItem(key, clientId);
    }

    $("roomTxt").textContent = room;
    $("roomInput").value = room;

    let currentRole = "Unknown";
    let currentVisitors = 0;

    function canDraw(){
      return currentRole === "Participant";
    }

    function canVoice(){
      return userProvidedClientId && currentRole === "Participant";
    }

    function applyRoomState(payload){
      if(payload && payload.role) currentRole = payload.role;
      if(payload && typeof payload.visitors === "number") currentVisitors = payload.visitors;

      $("roleTxt").textContent = currentRole;
      $("visitorsTxt").textContent = String(currentVisitors);

      $("viewerBanner").style.display = (currentRole !== "Participant") ? "block" : "none";

      updateVoiceUi();
      updateToolUi();
    }

    function updateVoiceUi(){
      if(!userProvidedClientId){
        $("voiceHint").textContent = "voice는 참가자 링크로 입장한 사람만 사용할 수 있습니다";
      }else if(currentRole !== "Participant"){
        $("voiceHint").textContent = "현재 role이 Participant가 아닙니다";
      }else{
        $("voiceHint").textContent = "";
      }
      $("startVoiceBtn").disabled = !canVoice() || callActive;
      $("stopVoiceBtn").disabled = !callActive;
    }

    function buildWsUrl(){
      const wsProto = (location.protocol === "https:") ? "wss" : "ws";
      return `${wsProto}://${location.host}/ws?room=${encodeURIComponent(room)}&clientId=${encodeURIComponent(clientId)}`;
    }

    let ws = null;

    function send(type, data = {}){
      if(!ws || ws.readyState !== WebSocket.OPEN) return;
      ws.send(JSON.stringify({ type, ...data }));
    }

    function connect(){
      const wsUrl = buildWsUrl();
      ws = new WebSocket(wsUrl);

      ws.addEventListener("open", () => {
        setConn(true);
        send("hello", {});
      });

      ws.addEventListener("close", () => {
        setConn(false);
        currentRole = "Unknown";
        $("roleTxt").textContent = currentRole;
        updateVoiceUi();
        updateToolUi();
      });

      ws.addEventListener("error", () => {
        setConn(false);
      });

      ws.addEventListener("message", async (evt) => {
        let msg = null;
        try{ msg = JSON.parse(evt.data); }catch(e){ return; }
        const type = msg.type || "";

        if(type === "room_state"){ applyRoomState(msg); return; }
        if(type === "draw"){ applyRemoteStroke(msg); return; }
        if(type === "clear"){ clearCanvas(false); return; }

        if(type === "voice_request"){ onVoiceRequest(msg); return; }
        if(type === "voice_accept"){ onVoiceAccept(msg); return; }
        if(type === "voice_reject"){ onVoiceReject(msg); return; }
        if(type === "voice_offer"){ await onVoiceOffer(msg); return; }
        if(type === "voice_answer"){ await onVoiceAnswer(msg); return; }
        if(type === "voice_ice"){ await onVoiceIce(msg); return; }
        if(type === "voice_stop"){ onVoiceStop(msg); return; }
      });
    }

    function hardReconnectToNewRoom(newRoom){
      room = newRoom;
      $("roomTxt").textContent = room;
      $("roomInput").value = room;

      try{ if(ws) ws.close(); }catch(e){}
      ws = null;

      teardownVoice("Idle");
      clearCanvas(false);

      const next = new URL(location.href);
      next.searchParams.set("room", room);
      if(userProvidedClientId) next.searchParams.set("clientId", clientId);
      if(label) next.searchParams.set("label", label);
      history.replaceState(null, "", next.toString());

      connect();
    }

    $("goRoomBtn").addEventListener("click", () => {
      const newRoom = ($("roomInput").value || "").trim();
      if(!newRoom) return;
      hardReconnectToNewRoom(newRoom);
    });

    $("backBtn").addEventListener("click", () => { location.href = "/"; });

    // tools
    const swatchColors = [
      "#E8EEF9",
      "#22C55E",
      "#3B82F6",
      "#A855F7",
      "#F59E0B",
      "#EF4444",
      "#14B8A6",
      "#F472B6"
    ];

    let tool = "pen";
    let penColor = swatchColors[0];
    let penWidth = Number($("sizeSel").value);

    function setTool(next){
      tool = next;
      updateToolUi();
    }

    function updateToolUi(){
      $("toolPen").classList.toggle("active", tool === "pen");
      $("toolEraser").classList.toggle("active", tool === "eraser");

      const text =
        "Tool " + tool.toUpperCase() +
        "  Size " + penWidth +
        (tool === "pen" ? "  Color " + penColor : "");

      $("toolInfo").textContent = text;

      const disabled = !canDraw();
      $("toolPen").disabled = disabled;
      $("toolEraser").disabled = disabled;
      $("sizeSel").disabled = disabled;
      $("clearBtn").disabled = disabled;

      // color only for pen
      const sw = $("swatches").querySelectorAll("button");
      sw.forEach(b => b.disabled = disabled || tool !== "pen");
    }

    function renderSwatches(){
      const box = $("swatches");
      box.textContent = "";
      for(const c of swatchColors){
        const b = document.createElement("button");
        b.type = "button";
        b.className = "swatch" + (c === penColor ? " active" : "");
        b.style.background = c;
        b.addEventListener("click", () => {
          if(tool !== "pen") return;
          penColor = c;
          renderSwatches();
          updateToolUi();
        });
        box.appendChild(b);
      }
    }

    $("toolPen").addEventListener("click", () => setTool("pen"));
    $("toolEraser").addEventListener("click", () => setTool("eraser"));
    $("sizeSel").addEventListener("change", () => {
      penWidth = Number($("sizeSel").value);
      updateToolUi();
    });

    renderSwatches();
    updateToolUi();

    // drawing
    const canvas = $("board");
    const ctx = canvas.getContext("2d");
    let drawing = false;
    let last = null;

    function resize(){
      const rect = canvas.getBoundingClientRect();
      const dpr = Math.max(1, window.devicePixelRatio || 1);
      canvas.width = Math.floor(rect.width * dpr);
      canvas.height = Math.floor(rect.height * dpr);
      ctx.setTransform(dpr,0,0,dpr,0,0);
      ctx.lineCap = "round";
      ctx.lineJoin = "round";
    }
    window.addEventListener("resize", resize);
    resize();

    function posFromEvent(e){
      const rect = canvas.getBoundingClientRect();
      return { x: (e.clientX - rect.left), y: (e.clientY - rect.top) };
    }

    function stroke(a, b, payload){
      const mode = payload.mode || "pen";
      const w = Number(payload.w || 3);
      const color = payload.color || "#E8EEF9";

      const prev = ctx.globalCompositeOperation;
      if(mode === "eraser"){
        ctx.globalCompositeOperation = "destination-out";
        ctx.strokeStyle = "rgba(0,0,0,1)";
      } else {
        ctx.globalCompositeOperation = "source-over";
        ctx.strokeStyle = color;
      }
      ctx.lineWidth = w;

      ctx.beginPath();
      ctx.moveTo(a.x, a.y);
      ctx.lineTo(b.x, b.y);
      ctx.stroke();

      ctx.globalCompositeOperation = prev;
    }

    function applyRemoteStroke(msg){
      if(!msg || !msg.a || !msg.b) return;
      stroke(msg.a, msg.b, msg);
    }

    function clearCanvas(broadcast){
      ctx.clearRect(0,0,canvas.width,canvas.height);
      if(broadcast) send("clear", {});
    }

    function start(e){
      if(!canDraw()) return;
      drawing = true;
      last = posFromEvent(e);
    }

    function move(e){
      if(!drawing) return;
      const p = posFromEvent(e);

      const payload = {
        mode: tool,
        color: penColor,
        w: penWidth,
      };

      stroke(last, p, payload);
      send("draw", { a:last, b:p, ...payload });

      last = p;
    }

    function end(){
      drawing = false;
      last = null;
    }

    canvas.addEventListener("pointerdown", (e) => {
      canvas.setPointerCapture(e.pointerId);
      start(e);
    });
    canvas.addEventListener("pointermove", move);
    canvas.addEventListener("pointerup", end);
    canvas.addEventListener("pointercancel", end);

    $("clearBtn").addEventListener("click", () => {
      if(!canDraw()) return;
      const ok = confirm("전체를 지울까요");
      if(!ok) return;
      clearCanvas(true);
    });

    // voice
    let pc = null;
    let localStream = null;
    let callActive = false;
    let isInitiator = false;

    const rtcConfig = { iceServers: [{ urls: ["stun:stun.l.google.com:19302"] }] };

    function setVoiceState(t){
      $("voiceState").textContent = t;
      updateVoiceUi();
    }

    async function ensureLocalAudio(){
      if(localStream) return localStream;
      localStream = await navigator.mediaDevices.getUserMedia({ audio:true, video:false });
      return localStream;
    }

    async function createPeer(){
      pc = new RTCPeerConnection(rtcConfig);

      pc.onicecandidate = (e) => {
        if(e.candidate) send("voice_ice", { candidate: e.candidate });
      };

      pc.ontrack = (e) => {
        const stream = e.streams && e.streams[0];
        if(stream) $("remoteAudio").srcObject = stream;
      };

      const stream = await ensureLocalAudio();
      stream.getTracks().forEach(t => pc.addTrack(t, stream));
    }

    $("startVoiceBtn").addEventListener("click", async () => {
      if(!userProvidedClientId){
        alert("voice는 참가자 링크로 입장한 사람만 사용할 수 있습니다");
        return;
      }
      if(currentRole !== "Participant"){
        alert("Participant만 음성을 시작할 수 있습니다");
        return;
      }
      if(callActive){
        alert("이미 통화가 진행 중입니다");
        return;
      }
      setVoiceState("Requesting");
      send("voice_request", {});
    });

    $("stopVoiceBtn").addEventListener("click", () => {
      if(!callActive) return;
      send("voice_stop", {});
      teardownVoice("Stopped");
    });

    function onVoiceRequest(){
      if(!canVoice()){ send("voice_reject", { reason:"not_allowed" }); return; }
      if(callActive){ send("voice_reject", { reason:"busy" }); return; }

      const ok = confirm("상대가 음성 연결을 요청했습니다. 수락할까요");
      if(!ok){ send("voice_reject", { reason:"rejected" }); return; }

      send("voice_accept", {});
      setVoiceState("Accepted");
    }

    async function onVoiceAccept(){
      if(callActive) return;
      try{
        isInitiator = true;
        callActive = true;
        setVoiceState("Creating offer");
        await createPeer();

        const offer = await pc.createOffer({ offerToReceiveAudio:true });
        await pc.setLocalDescription(offer);
        send("voice_offer", { sdp: offer });
        setVoiceState("Offer sent");
      }catch(e){
        teardownVoice("Voice error");
      }
    }

    function onVoiceReject(){
      callActive = false;
      isInitiator = false;
      setVoiceState("Rejected");
      alert("상대가 음성 요청을 거절했습니다");
    }

    async function onVoiceOffer(msg){
      if(callActive && isInitiator) return;
      try{
        if(!callActive){ callActive = true; isInitiator = false; }
        setVoiceState("Received offer");
        await createPeer();

        await pc.setRemoteDescription(new RTCSessionDescription(msg.sdp));
        const answer = await pc.createAnswer();
        await pc.setLocalDescription(answer);
        send("voice_answer", { sdp: answer });
        setVoiceState("Answer sent");
      }catch(e){
        teardownVoice("Voice error");
      }
    }

    async function onVoiceAnswer(msg){
      if(!pc) return;
      try{
        await pc.setRemoteDescription(new RTCSessionDescription(msg.sdp));
        setVoiceState("Connected");
      }catch(e){
        teardownVoice("Voice error");
      }
    }

    async function onVoiceIce(msg){
      if(!pc || !msg || !msg.candidate) return;
      try{ await pc.addIceCandidate(new RTCIceCandidate(msg.candidate)); }catch(e){}
    }

    function onVoiceStop(){
      teardownVoice("Peer stopped");
      alert("상대가 음성을 종료했습니다");
    }

    function teardownVoice(stateText){
      callActive = false;
      isInitiator = false;

      try{ if(pc) pc.close(); }catch(e){}
      pc = null;

      try{ if(localStream) localStream.getTracks().forEach(t => t.stop()); }catch(e){}
      localStream = null;

      try{ $("remoteAudio").srcObject = null; }catch(e){}
      setVoiceState(stateText || "Idle");
    }

    setVoiceState("Idle");
    connect();
  </script>
</body>
</html>
