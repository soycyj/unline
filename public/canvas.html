<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Unline Voice</title>
  <style>
    :root{--bg:#0b0d10;--panel:rgba(20,24,33,0.92);--line:rgba(39,48,68,0.9);--text:#e8eef9;--muted:#a9b4c7;--btn:#1f6feb;--btn2:#2b3242;--danger:#ef4444}
    *{box-sizing:border-box} html,body{height:100%}
    body{margin:0;background:var(--bg);color:var(--text);font-family:system-ui,-apple-system,Segoe UI,Roboto;display:flex;flex-direction:column}
    .bar{display:flex;gap:10px;flex-wrap:wrap;align-items:center;justify-content:space-between;padding:12px;border-bottom:1px solid var(--line);background:rgba(10,12,16,0.6);position:sticky;top:0}
    .left,.right{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
    .pill{padding:6px 10px;border:1px solid var(--line);border-radius:999px;background:rgba(20,24,33,0.6);font-size:12px;color:var(--muted);font-weight:900}
    .pill strong{color:var(--text)}
    button{padding:10px 12px;border:1px solid var(--line);border-radius:12px;background:var(--btn2);color:var(--text);font-weight:900;cursor:pointer}
    button.primary{background:var(--btn);border-color:rgba(31,111,235,0.75)}
    button.danger{background:rgba(239,68,68,0.12);border-color:rgba(239,68,68,0.35);color:#fecaca}
    button:disabled{opacity:0.55;cursor:not-allowed}
    .wrap{display:grid;grid-template-columns:1fr;gap:12px;padding:12px}
    .card{background:var(--panel);border:1px solid var(--line);border-radius:16px;padding:12px}
    .small{margin:8px 0 0;font-size:12px;color:var(--muted);line-height:1.5}
  </style>
</head>
<body>
  <div class="bar">
    <div class="left">
      <div class="pill">Room <strong id="roomTxt"></strong></div>
      <div class="pill">Role <strong id="roleTxt">viewer</strong></div>
      <div class="pill">Visitors <strong id="visitorsTxt">0</strong></div>
      <div class="pill">WS <strong id="wsTxt">offline</strong></div>
      <div class="pill">BUILD <strong id="buildTxt">na</strong></div>
    </div>
    <div class="right">
      <button id="homeBtn">Home</button>
    </div>
  </div>

  <div class="wrap">
    <div class="card">
      <div style="display:flex;gap:10px;flex-wrap:wrap;align-items:center">
        <button id="enableAudioBtn">Enable audio</button>
        <button id="startVoiceBtn" class="primary">Start voice</button>
        <button id="stopVoiceBtn" class="danger" disabled>Stop</button>
      </div>
      <p class="small" id="voiceState">Idle</p>
      <p class="small" id="dbg"></p>
      <audio id="remoteAudio" autoplay playsinline></audio>
    </div>
  </div>

  <script>
    const $ = (id) => document.getElementById(id);
    const qs = new URLSearchParams(location.search);

    const room = (qs.get("room") || "VOICE01").trim();
    const clientId = (qs.get("clientId") || ("c" + Math.random().toString(16).slice(2,10))).trim();
    const label = (qs.get("label") || "").trim();

    $("roomTxt").textContent = room;

    $("homeBtn").addEventListener("click", () => location.href = "/");

    function dbg(t){ $("dbg").textContent = t || ""; }

    function wsUrl(){
      const proto = location.protocol === "https:" ? "wss" : "ws";
      return `${proto}://${location.host}/ws?room=${encodeURIComponent(room)}&clientId=${encodeURIComponent(clientId)}&label=${encodeURIComponent(label)}`;
    }

    let ws;
    function send(type, data){
      if (!ws || ws.readyState !== WebSocket.OPEN) return;
      ws.send(JSON.stringify({ type, ...(data || {}) }));
    }

    let meRole = "viewer";
    let visitors = 0;

    function canVoice(){ return meRole === "participant"; }

    function updateUi(){
      $("roleTxt").textContent = meRole;
      $("visitorsTxt").textContent = String(visitors);
      $("startVoiceBtn").disabled = !canVoice() || callActive;
      $("stopVoiceBtn").disabled = !callActive;
    }

    function setVoiceState(t){ $("voiceState").textContent = t; updateUi(); }

    let iceServers = [{ urls: ["stun:stun.l.google.com:19302"] }];
    async function loadIce(){
      try{
        const r = await fetch("/api/ice", { cache: "no-store" });
        const j = await r.json();
        if (j && j.build) $("buildTxt").textContent = j.build;
        if (j && j.ok && Array.isArray(j.iceServers) && j.iceServers.length) iceServers = j.iceServers;
      }catch{}
    }

    let audioCtx = null;
    async function unlockAudio(){
      const a = $("remoteAudio");
      try { await a.play(); } catch {}
      const Ctx = window.AudioContext || window.webkitAudioContext;
      if (Ctx && !audioCtx) audioCtx = new Ctx();
      if (audioCtx && audioCtx.state === "suspended") {
        try { await audioCtx.resume(); } catch {}
      }
    }

    let pc = null;
    let localStream = null;
    let callActive = false;

    async function ensureLocalAudio(){
      if (localStream) return localStream;
      localStream = await navigator.mediaDevices.getUserMedia({
        audio: { echoCancellation:true, noiseSuppression:true, autoGainControl:true },
        video: false
      });
      return localStream;
    }

    async function createPeer(){
      pc = new RTCPeerConnection({ iceServers });

      pc.onicecandidate = (e) => {
        if (e.candidate) send("voice_ice", { candidate: e.candidate });
      };

      pc.oniceconnectionstatechange = () => dbg("ice " + pc.iceConnectionState);
      pc.onconnectionstatechange = () => dbg("conn " + pc.connectionState);

      pc.ontrack = async (e) => {
        const stream = e.streams && e.streams[0];
        if (!stream) return;
        const a = $("remoteAudio");
        a.srcObject = stream;
        try { await a.play(); dbg("remote playing"); }
        catch { dbg("remote blocked"); }
      };

      const s = await ensureLocalAudio();
      s.getTracks().forEach(t => pc.addTrack(t, s));
    }

    function teardown(reason){
      try { if (pc) pc.close(); } catch {}
      pc = null;
      try { if (localStream) localStream.getTracks().forEach(t => t.stop()); } catch {}
      localStream = null;
      callActive = false;
      setVoiceState(reason || "Idle");
      dbg("");
    }

    $("enableAudioBtn").addEventListener("click", async () => {
      await unlockAudio();
      dbg("audio unlocked");
    });

    $("startVoiceBtn").addEventListener("click", async () => {
      dbg("start tapped");
      await unlockAudio();

      if (!canVoice()) { dbg("blocked role"); return; }
      if (!ws || ws.readyState !== WebSocket.OPEN) { dbg("ws not open"); return; }
      if (callActive) return;

      try { await ensureLocalAudio(); }
      catch { dbg("mic denied"); return; }

      setVoiceState("Requesting");
      send("voice_request", {});
    });

    $("stopVoiceBtn").addEventListener("click", () => {
      if (!callActive) return;
      send("voice_stop", {});
      teardown("Stopped");
    });

    function onVoiceRequest(){
      if (!canVoice()) { send("voice_reject", { reason: "not_allowed" }); return; }
      if (callActive) { send("voice_reject", { reason: "busy" }); return; }

      const ok = confirm("Voice request. Accept");
      if (!ok) { send("voice_reject", { reason: "rejected" }); return; }

      send("voice_accept", {});
      setVoiceState("Accepted");
    }

    async function onVoiceAccept(){
      if (callActive) return;
      try{
        callActive = true;
        setVoiceState("Creating offer");
        await createPeer();
        const offer = await pc.createOffer({ offerToReceiveAudio: true });
        await pc.setLocalDescription(offer);
        send("voice_offer", { sdp: offer });
        setVoiceState("Offer sent");
      }catch{
        teardown("Voice error");
      }
    }

    function onVoiceReject(){
      callActive = false;
      setVoiceState("Rejected");
    }

    async function onVoiceOffer(msg){
      try{
        if (!callActive) callActive = true;
        setVoiceState("Received offer");
        await createPeer();
        await pc.setRemoteDescription(new RTCSessionDescription(msg.sdp));
        const answer = await pc.createAnswer();
        await pc.setLocalDescription(answer);
        send("voice_answer", { sdp: answer });
        setVoiceState("Answer sent");
      }catch{
        teardown("Voice error");
      }
    }

    async function onVoiceAnswer(msg){
      if (!pc) return;
      try{
        await pc.setRemoteDescription(new RTCSessionDescription(msg.sdp));
        setVoiceState("Connected");
      }catch{
        teardown("Voice error");
      }
    }

    async function onVoiceIce(msg){
      if (!pc || !msg || !msg.candidate) return;
      try { await pc.addIceCandidate(new RTCIceCandidate(msg.candidate)); } catch {}
    }

    function onVoiceStop(){ teardown("Peer stopped"); }

    async function boot(){
      await loadIce();

      ws = new WebSocket(wsUrl());

      ws.addEventListener("open", () => {
        $("wsTxt").textContent = "online";
      });

      ws.addEventListener("close", () => {
        $("wsTxt").textContent = "offline";
      });

      ws.addEventListener("message", (evt) => {
        let msg;
        try { msg = JSON.parse(evt.data); } catch { return; }

        if (msg.type === "room_state") {
          visitors = msg.visitors || 0;
          const me = (msg.users || []).find(u => u.clientId === clientId);
          if (me && me.role) meRole = me.role;
          updateUi();
          return;
        }

        if (msg.type === "voice_request") return onVoiceRequest();
        if (msg.type === "voice_accept") return onVoiceAccept();
        if (msg.type === "voice_reject") return onVoiceReject();
        if (msg.type === "voice_offer") return onVoiceOffer(msg);
        if (msg.type === "voice_answer") return onVoiceAnswer(msg);
        if (msg.type === "voice_ice") return onVoiceIce(msg);
        if (msg.type === "voice_stop") return onVoiceStop();
      });

      updateUi();
    }

    boot();
  </script>
</body>
</html>
